剪枝方法总结：

1.优化搜索顺序

在一些问题中，搜索树的各个分支之间的顺序是不固定的

不同的搜索顺序会产生不同的搜索形态，规模也相差甚远

2.排除等效分支

在搜索过程中，如果我们能够得知搜索树的当前节点沿着

某几条不同分支到达的子树是等效的，那么只需要对其中

一条路径进行搜索

3.是否可行剪枝

在搜索过程中，每次对当前状态进行检查，如果发现不可

能到达递归边界，就执行回溯

4.最优性剪枝

在求解最优解的过程中，如果当前解已经没有当前最优解

优秀，此时可以执行回溯语句

5.记忆化剪枝

记录每个状态的搜索结果，在重复遍历一个状态时返回

 



BFS问题可以按下面步骤处理：

         1）设计状态
    
         对于上面的问题，我把当前人的位置以及人到该位置所花费的最小时间t，即x和y坐标(行与列坐标)与时间t作为一个有效状态。严格来说x和y才算状态属性，而t只能算状态的当前值。而我们要求的是终点状态的最小时间t值。
    
         对于每个有效状态X，它可以继续延伸出后继状态。比如本题的X状态的后继状态就是当人在X点然后向上下左右4个方向走时所产生的后继状态(假设4个方向的格子都能走)。
    
         对于相同的状态我们只处理一次，如果某个状态的后继状态是之前我们已经处理过的状态，那么直接抛弃这个后继状态，不入队列。
    
        什么样的状态是一个有效的状态？当给你任意一个BFS状态后，你能根据这个状态把当前BFS网格地图(或BFS全局状态)整个还原出来，那么这个状态就是一个有效的状态。
    
         2）记录同类状态最优值
    
         就是要记录当达到任意一个同类状态(对于本题我们把坐标值相同的状态看成是同一类的)时的最优效果。比如本题，令dist[i][j]==t表示当人到达(i, j)这类状态时，所需要的最小时间t。这个最小时间就是我们要的最优效果。
    
         3）状态剪枝
    
         每个状态的后继状态一般都有好几个，这样我们只要做几轮出队入队操作，队列中的状态就是变成指数级别了。所以对于那些出现多次的同类状态，我们只保存一个入队列。且如果上面dist[4][5]==2(即花了2步从起点走到(4,5)点)，
    	 那么当某个后继状态是(4,5,3)时，我们果断抛弃这个状态(想想为什么，其实(4,5,2)我们就可以抛弃)。
    
         (其实通过下面的题目可以知道，有些状态需要很多元素来表示，直接导致如果用dist数组来判定重复将会定义dist为dist[][][][][][][][][][]这样，所以这时候我们采取的策略是：HASH判重+保存所有已出现的非重复状态)
    
         4）查找目标状态
    
         这个就是当我们在生成后继状态的时候看看是否有目标状态出现(比如坐标在终点的状态)。对于本题来说，只要出现了一个目标状态，我们直接退出即可。因为后面出现的目标状态所花的时间肯定更多。