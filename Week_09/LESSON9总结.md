布隆过滤器:

布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。
时间和空间效率较高（与hash比较）

LRU缓存：

 无论是哪一层次的缓存都面临一个同样的问题：当容量有限的缓存的空闲空间全部用完后，又有新的内容需要添加进缓存时，如何挑选并舍弃原有的部分内容，从而腾出空间放入这些新的内容。解决这个问题的算法有几种，如最近使用算法（LRU）、先进先出算法（FIFO）、最近最少使用算法（LFU）、非最近使用算法（NMRU）等，这些算法在不同层次的缓存上执行时拥有不同的效率和代价，需根据具体场合选择最合适的一种。 

LRU: 常用的实现是使用下图中的方式，往头部加入新的数据，如果该数据存在则将其放到头部，如果加入时已满，则从底部淘汰掉数据。  这种方式虽然简单，在频繁访问热点数据的时候效率高，但是它的缺点在于如果是偶尔的批量访问不同的数据时其命中率就会很低。比如我频繁的访问A，接着访问不同的数据直到A被淘汰，此时我再访问A，则不得不又再次把A加入到Cache中，显然这种方式是不合时宜的，因为A已经访问了很多次了，不应该将其淘汰而把一堆只访问一次的数据加入到Cache中。 

LRU-K: 上面的`LRU`只会将最近使用的一次加入到缓存，因此需要将其进行优化，变成缓存`k`次的才加入到缓存中，于是我们需要维护一个历史队列，纪录其数据对应的访问次数，其根据访问次数来进行淘汰，如果访问次数达到了`k`次才从历史队列中删除加入到缓存中，缓存按照LRU的规则来淘汰数据。  它的命中率要比LRU要高，但是因为需要维护一个历史队列，因此内存消耗会比LRU多。  实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。 




